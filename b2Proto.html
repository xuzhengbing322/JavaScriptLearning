<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <button id="btn">点击</button>

    <script type="text/javascript">
        /* 1、原型
        函数和类才具有prototype原型对象。prototype对象中包括程序员定义的属性和方法、constructor、
__proto__。constructor属性值为实例化该对象的构造函数。__proto__属性值为prototype的引用函数的父函数
的prototype。
        所有的对象都有__proto__属性，属性的值为构造该对象的构造函数的prototype。
即，text.__proto__ === Text.prototype。因此，对象prototype中的属性和方法即为constructor指向
的构造函数的prototype中的属性和方法。构造函数其实也有__proto__，指向的是Function.prototype。
        原型链就是以一个对象为基准，以__proto__为连接，以prototype为节点的链条。链条的顶端是
Object.prototype。
        原型链的功能：访问属性时，就是根据原型链来查找属性。先查找实例对象自身的属性，找不到，再去对象的
__proto__属性指向的prototype中查找，并一直沿着原型链查找属性，直至查找到属性并返回。如果找到原型链顶端
Object.prototype依旧没找到属性，则返回undefined。
        原型链和作用域链的区别：原型链是构造函数与实例对象之间链条，作用域链是AO/GO的链条。
        text {
            a: 1,
            __proto__: Text.prototype = {
                                    b: 2,
                                    constructor: f Text()
                                    __proto__: Object.prototype = {
                                                                 c: 3,
                                                                 constructor: f Object()
                                                                 __proto__: null
                                                                }
                                    }
        }
    
        */

        function Text() {
            this.a = 1
        }

        Text.prototype.b = 2
        Object.prototype.c = 3
        console.log("Text.prototype", Text.prototype)

        const text = new Text();
        console.log("test", text)
        console.log("text.__proto__", text.__proto__);
        console.log(text.__proto__ === Text.prototype) //true
        console.log(Text.prototype.__proto__ === Object.prototype) //true
        console.log(Object.prototype.__proto__) //null  
        console.log(text.prototype)  //undefined


        // Function Object: 函数、对象
        console.log(Text.__proto__)
        // 构造函数的__proto__指向Function的prototype
        console.log("#", Text.__proto__ === Function.prototype) //true
        const tezt = new Function()
        console.log(Function.__proto__)  //f
        console.log(Function.__proto__ === Function.prototype)  //true

        console.log(typeof Object) //function
        console.log(Object.__proto__ === Function.prototype);  //true
        console.log(Object.__proto__ === Function.__proto__)  //true
        //    text.constructor指向的是构造函数Text
        console.log(text.constructor === Text)  //true

        // 原型链的属性访问
        function CarA() {
            this.brand = 'Benz';
        }

        CarA.prototype = {
            brand: 'Mazda',
            intro: function () {
                console.log(`我是${this.brand}车`)
            }
        }

        let cara = new CarA()
        // this指向car实例对象，构造函数中有brand，所以用构造函数自身的brand。
        cara.intro()   //我是Benz车
        CarA.prototype.intro()  //我是Mazda车

        /*2、prototype的特点
        prototype中的this默认指向实例对象。程序员在函数上自定义属性和方法中的this默认指向window。
因此，程序员想给函数添加属性和方法都是在原型prototype上添加，而非自定义属性。
        构造函数每次实例化都相当于是要给实例对象添加属性和方法。将静态的属性和方法写在原型上，将动态的
属性写在构造函数中，避免静态属性和方法经历实例化的过程。因此，构造函数内部，挂载到this上的都是可配置的
属性变量
        给构造函数的原型添加属性和方法，建议使用Fun.prototype.init =function() {}，而不是
Fun.prototype = { init : function() {}}。这样避免将以前写在原型上的属性和方法给覆盖了。
        实例对象无法增加/删除/更改prototype中的属性，它只能增加/删除/更改的是构造函数中的属性。   
        */
        function Handphone(color, brand) {
            this.color = color;
            this.brand = brand;
        }

        Handphone.prototype = {
            rom: '64G',
            ram: '6G',
            screen: '18:9',
            system: 'Android',
            call: function () {
                console.log(`I am calling somebody`)
            }
        }


        let hp1 = new Handphone('red', '小米')
        let hp2 = new Handphone('black', '华为')
        hp1.rom = '32G'  //这只是给实例对象添加属性，并不能修改原型上的属性。
        console.log(hp1.rom);  //32G
        console.log(hp2.rom);  //64G
        hp2.call()
        console.log("hp1", hp1)


        /*3、构造器constructor
            构造器constructor存在于prototype中，constructor默认指向当前prototype的引用构造函数。
当然也可以修改构造器的指向。实例化构造函数就是将原型中的构造器给实例化。
            构造器存储着构造函数的prototype中未被实例化的属性和方法。实例化构造函数时，构造器中的内容
就会变成prototype上的内容。也就是说，constructor保存的是实例化之前的东西。
            Car.prototype.constructor -> Car() -> prototype -> name:apple
            在构造函数没有实例化之前，构造函数.prototype.constructor指向的就是构造函数本身。构造函数
的prototype中有name属性。当构造函数实例化的时候，就是将构造器的属性拿到实例对象中的prototype中。
                */

        Food.prototype.name = 'banana';
        function Food() {
            this.price = "12"
        }
        let foodBefore = new Food()
        Food.prototype = {
            name: 'apple'
        }
        let foodAfter = new Food()
        console.log('foodBefore', foodBefore) //food的prototype中的name属性值为banana
        console.log('foodAfter', foodAfter)  //food2的prototype中的name属性值为apple

        /*把构造函数Food的原型prototype中的constructor指向构造函数Telephone，原本默认指向
构造函数Handphone。new Food()依旧是实例化Food()，但通过new food3.constructor()实例化的就是
Telephone()。
        */
        Telephone.prototype.number = '18100000000';
        function Telephone() {
            this.name = '张三';
        }

        Food.prototype = {
            snumber: '11100000000',
            constructor: Telephone
        }

        let foodChange = new Food()
        let newFoodChange = new foodChange.constructor
        console.log('foodChange', foodChange)
        console.log('newFoodChange', newFoodChange)

        /* 4、继承
        4.1、原型链继承
        * Teacher.prototype = professor：将父构造函数的实例对象赋给子构造函数的原型，从而实现继承。
原理：this.__proto__ ===  Teacher.prototype === professor，
professor.__proto__ === Professor.prototype。
        * 实例对象可以修改该对象原型中的属性，但无法修改父构造函数中的属性。但是不推荐。
        4.2、apply()实现继承。
        构造函数的this指向实例对象。子构造函数中，Father.apply(this, [...])中的this依旧是实例对象，
只是执行Father()，从而实现继承Father()。只不过这种方法无法继承Father()的原型。
        4.3、圣杯继承

        */
        Professor.prototype.tSkill = 'JAVA';
        function Professor() { }
        let professor = new Professor();

        Teacher.prototype = professor;
        function Teacher() {
            this.mSkill = 'JS/JQ',
                this.success = {
                    alibaba: '28',
                    tencent: '30'
                },
                this.students = 500
        }
        let teacher = new Teacher();

        Student.prototype = teacher;
        function Student() {
            this.pSkill = 'HTML/CSS';
        }
        let student = new Student();
        student.success.baidu = '100'
        student.success.alibaba = '29'
        student.students = 400
        student.students++;
        console.log("teacher:",teacher,"student:", student)  //teacher 500 student 401
        let studentTwo = new Student();
        console.log("studentTwo",studentTwo) //500

        

        //通过apply改变this指向，从而借用其他函数的属性和方法，但它没办法借用其他函数的原型。
        Father.prototype.wife = 'Ms. Liu';
        function Father(name, mSkill) {
            this.name = name;
            this.mSkill = mSkill;
        }
        function Child(name, mSkill, age, major) {
            Father.apply(this, [name, mSkill]);
            this.age = age;
            this.major = major;
        }

        let child = new Child('Mr. Zhang', 'JS/JQ', 18, 'Computer')
        console.log('child', child)

        /*圣杯继承
        * 圣杯继承解决的问题：公共原型问题。将父构造函数的prototype直接赋给子构造函数的prototype。
这种方式虽然实现了子构造函数的实例对象继承父构造函数的prototype，但是实例对象不在拥有子构造函数prototype
中的属性，而且更改子构造对象的prototype，父构造函数的prototype也会被修改。这都是因为直接赋值让父子
prototype的指针都指向父构造函数的prototype，即同一个堆内存空间。
        * 圣杯模式就是为了解决公共原型的问题。  原理是创建一个Buffer空构造函数作为中间件。将父构造函数
的prototype赋给Buffer的prototype，由此实现继承，且有公共原型的问题。然后实例化Buffer()，将实例对象
buffer赋给子构造函数的prototype。
        当子构造函数的实例对象访问自身__proto__时，访问的就是buffer。buffer访问自身__proto__时，
访问的就是Buffer.prototype，即父构造函数的prototype。由此实现子构造函数的实例对象继承父构造函数
的prototype。操作子构造函数的prototype实际操作的是buffer，而非Buffer.prototype/父构造函数的prototype。
因此，值不会有所改变。从而解决了公共原型的问题。
        其实所谓的继承原型，就是更改对象在栈内存的引用。
        */
    //    公共原型问题。
        function TeacherFun() {
            this.name = 'Mr. Li';
            this.tSkill = 'Java';
        }

        TeacherFun.prototype = {
            pSkill: 'JS/JQ'
        }

        let tea = new TeacherFun();
        console.log('teacher', tea);

        StudentFun.prototype = {
            school: 'gunx'
        }
        function StudentFun() {
            this.name = 'Mr. Wang';
        }
        StudentFun.prototype = TeacherFun.prototype;
        StudentFun.prototype.age = 18; //Student原型和Teacher原型上都有age属性
        console.log("StudentFun.prototype",StudentFun.prototype,"TeacherFun.prototype",TeacherFun.prototype)
        let stu = new StudentFun()
        console.log('student', stu)

        /*继承  圣杯模式
        */
        TeacherGrail.prototype = {
            pSkill: 'JS/JQ'
        }

        function TeacherGrail() {
            this.name = 'Mr. Li';
            this.tSkill = 'Java';
        }
        // 因为中间件是空函数，因此子原型必然是空对象。要给子原型添加属性和方法，需要在继承之后添加
        StudentGrail.prototype = {
            sSkill: 'HTML'
        }

        function StudentGrail() {
            this.name = 'Mr. Wang';
        }
        // 封装中间件，即继承功能部分。
        function inherit(Target, Origin) {
            function Buffer() { }
            Buffer.prototype = Origin.prototype;
            Target.prototype = new Buffer()
            // 继承后，Target.prototype.constructor = Origin，因此需要变为本身。
            Target.prototype.constructor = Target
            Target.prototype.super_class = Origin  //保存继承源，以便找到真正继承的构造函数。
        }

        inherit(StudentGrail, TeacherGrail)

        let sGrail = new StudentGrail()
        console.log('sGrail', sGrail)

        // 圣杯模式的闭包  这就是模块化开发，自执行函数有自己的作用域了，防止全局污染。
        // let inherit = (function () {
        //     var Buffer = function () { }
        //     return  function(Target, Origin) {
        //         Buffer.prototype = Origin.prototype;
        //         Target.prototype = new Buffer()
        //         Target.prototype.constructor = Target
        //         Target.prototype.super_class = Origin  //保存继承源，以便找到真正继承的构造函数。
        //     }
        //    // return inherit
        // })()



        /*
        callee/caller
        callee：返回正在被执行的函数对象。callee是实参列表中的一个属性。
        也就是说，arguments实参列表所对应的函数是谁，callee就返回哪个函数。
        */
        // function test(a, b, c) {
        //     console.log(arguments.callee)  //返回正在被执行的函数
        //     console.log(arguments.callee.length)
        //     console.log(test.length)  //两者基本相等。
        //     console.log(arguments.length)
        // }
        // test(1, 2)

        // function test1() {
        //     console.log(arguments.callee)
        //     function test2() {
        //         console.log(arguments.callee)
        //     }
        //     test2();
        // }
        // test1();


        //当无法用名字来找函数时，就用arguments.callee来找函数本身。
        // var sum = (function(n){
        //     if(n <= 1){
        //         return 1
        //     }
        //     return n + arguments.callee(n - 1)
        // })(100)

        // console.log(sum)

        //caller：返回当前被调用函数的函数引用。也就是说，谁调用了test2，它就返回那一个函数。
        // test1()
        // function test1() {
        //     test2();
        // }
        // function test2() {
        //     console.log(test2.caller())
        // }

    </script>
</body>

</html>